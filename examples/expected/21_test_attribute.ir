; Module: root

; String literals:
;   lit0 = "a = {}"
;   lit1 = "x = {}"

fn Vec::new() -> Vec {

    block0:
        v0 = iconst i32 0
        v1 = call 81923(v0)
        v2 = iconst i32 0
        v3 = iconst i32 0
        v4 = struct_create Vec { v1, v2, v3 }
        ret v4

}

fn Vec::with_capacity(arg0: i32) -> Vec {

    block0:
        v6 = call 81923(v5)
        v7 = iconst i32 0
        v8 = struct_create Vec { v6, v7, v5 }
        ret v8

}

fn Vec::len(arg0: *Vec) -> i32 {

    block0:
        v10 = load Vec, v9
        v11 = struct_get v10, 1
        ret v11

}

fn Vec::capacity(arg0: *Vec) -> i32 {

    block0:
        v13 = load Vec, v12
        v14 = struct_get v13, 2
        ret v14

}

fn Vec::grow(arg0: *Vec) -> () {

    block0:
        v16 = load Vec, v15
        v17 = struct_get v16, 0
        v18 = load Vec, v15
        v19 = struct_get v18, 2
        v20 = iconst i32 0
        v21 = icmp eq v19, v20
        br_if v21, then: block1(), else: block2()

    block1:
        v22 = iconst i32 1
        br block3(v22)

    block2:
        v23 = iadd v19, v19
        br block3(v23)

    block3(v24: i32):
        v25 = call 81923(v24)
        v26 = load Vec, v15
        v27 = struct_get v26, 1
        v28 = iconst i32 0
        v29 = icmp sgt v27, v28
        br_if v29, then: block4(), else: block5()

    block4:
        v30 = load Vec, v15
        v31 = struct_get v30, 1
        v32 = call 988124(v17, v25, v31)
        br block5

    block5:
        v33 = iconst i8 0
        v34 = iconst i32 0
        v35 = icmp sgt v19, v34
        br_if v35, then: block6(), else: block7()

    block6:
        v36 = call 22882(v17, v19)
        br block7

    block7:
        v37 = iconst i8 0
        v38 = alloca *Vec ; loc0
        store *Vec, v38, v15
        v39 = load *Vec, v38
        v40 = iconst i32 0
        v41 = iconst i32 0
        v42 = gep v39, [v40, v41]
        store *T, v42, v25
        v43 = load *Vec, v38
        v44 = iconst i32 0
        v45 = iconst i32 2
        v46 = gep v43, [v44, v45]
        store i32, v46, v24
        ret

}

fn Vec::push(arg0: *Vec, arg1: T) -> () {

    block0:
        v49 = load Vec, v47
        v50 = struct_get v49, 0
        v51 = load Vec, v47
        v52 = struct_get v51, 2
        v53 = iconst i32 0
        v54 = icmp eq v52, v53
        br_if v54, then: block1(), else: block2()

    block1:
        v55 = iconst i32 1
        br block3(v55)

    block2:
        v56 = iadd v52, v52
        br block3(v56)

    block3(v57: i32):
        v58 = load Vec, v47
        v59 = struct_get v58, 1
        v60 = load Vec, v47
        v61 = struct_get v60, 2
        v62 = icmp eq v59, v61
        br_if v62, then: block4(), else: block5()

    block4:
        v63 = call 827472(v50, v52, v57)
        br block6(v63)

    block5:
        v64 = load Vec, v47
        v65 = struct_get v64, 0
        br block6(v65)

    block6(v66: *T):
        v67 = load Vec, v47
        v68 = struct_get v67, 1
        v69 = load Vec, v47
        v70 = struct_get v69, 2
        v71 = icmp eq v68, v70
        br_if v71, then: block7(), else: block8()

    block7:
        br block9(v57)

    block8:
        v72 = load Vec, v47
        v73 = struct_get v72, 2
        br block9(v73)

    block9(v74: i32):
        v75 = alloca *Vec ; loc0
        store *Vec, v75, v47
        v76 = load *Vec, v75
        v77 = iconst i32 0
        v78 = iconst i32 0
        v79 = gep v76, [v77, v78]
        store *T, v79, v66
        v80 = load *Vec, v75
        v81 = iconst i32 0
        v82 = iconst i32 2
        v83 = gep v80, [v81, v82]
        store i32, v83, v74
        v84 = load *Vec, v75
        v85 = iconst i32 0
        v86 = iconst i32 0
        v87 = gep v84, [v85, v86]
        v88 = load *T, v87
        v89 = load *Vec, v75
        v90 = load Vec, v89
        v91 = struct_get v90, 1
        v92 = gep v88, [v91]
        store T, v92, v48
        v93 = load *Vec, v75
        v94 = load Vec, v93
        v95 = struct_get v94, 1
        v96 = iconst i32 1
        v97 = iadd v95, v96
        v98 = load *Vec, v75
        v99 = iconst i32 0
        v100 = iconst i32 1
        v101 = gep v98, [v99, v100]
        store i32, v101, v97
        ret

}

fn Vec::pop(arg0: *Vec) -> Option {

    block0:
        v103 = load Vec, v102
        v104 = struct_get v103, 1
        v105 = iconst i32 0
        v106 = icmp eq v104, v105
        br_if v106, then: block1(), else: block2()

    block1:
        v107 = enum_create Option, variant 0
        br block3(v107)

    block2:
        v108 = load Vec, v102
        v109 = struct_get v108, 1
        v110 = iconst i32 1
        v111 = isub v109, v110
        v112 = alloca *Vec ; loc0
        store *Vec, v112, v102
        v113 = load *Vec, v112
        v114 = iconst i32 0
        v115 = iconst i32 1
        v116 = gep v113, [v114, v115]
        store i32, v116, v111
        v117 = load *Vec, v112
        v118 = load Vec, v117
        v119 = struct_get v118, 0
        v120 = load *Vec, v112
        v121 = load Vec, v120
        v122 = struct_get v121, 1
        v123 = gep v119, [v122]
        v124 = load T, v123
        v125 = enum_create Option, variant 1 [v124]
        br block3(v125)

    block3(v126: Option):
        ret v126

}

fn Vec::get(arg0: *Vec, arg1: i32) -> Option {

    block0:
        v129 = load Vec, v127
        v130 = struct_get v129, 1
        v131 = icmp sge v128, v130
        br_if v131, then: block1(), else: block2()

    block1:
        v132 = enum_create Option, variant 0
        br block3(v132)

    block2:
        v133 = load Vec, v127
        v134 = struct_get v133, 0
        v135 = gep v134, [v128]
        v136 = load T, v135
        v137 = enum_create Option, variant 1 [v136]
        br block3(v137)

    block3(v138: Option):
        ret v138

}

fn Vec::index(arg0: *Vec, arg1: i32) -> Option {

    block0:
        v141 = load Vec, v139
        v142 = struct_get v141, 1
        v143 = icmp sge v140, v142
        br_if v143, then: block1(), else: block2()

    block1:
        v144 = enum_create Option, variant 0
        br block3(v144)

    block2:
        v145 = load Vec, v139
        v146 = struct_get v145, 0
        v147 = gep v146, [v140]
        v148 = load T, v147
        v149 = enum_create Option, variant 1 [v148]
        br block3(v149)

    block3(v150: Option):
        ret v150

}

fn test_basic() -> () {

    block0:
        v151 = iconst i32 1
        v152 = iconst i32 2
        v153 = iadd v151, v152
        v154 = sconst lit0
        v155 = iconst i32 1
        v156 = call 862609(v154, v155, v153)
        ret

}

fn test_multiplication() -> () {

    block0:
        v157 = iconst i32 4
        v158 = iconst i32 5
        v159 = imul v157, v158
        v160 = sconst lit1
        v161 = iconst i32 1
        v162 = call 862609(v160, v161, v159)
        ret

}
