; Module: root

fn Vec::new() -> Vec {

    block0:
        v0 = iconst i32 0
        v1 = call 81923(v0)
        v2 = iconst i32 0
        v3 = iconst i32 0
        v4 = struct_create Vec { v1, v2, v3 }
        ret v4

}

fn Vec::with_capacity(arg0: i32) -> Vec {

    block0:
        v6 = call 81923(v5)
        v7 = iconst i32 0
        v8 = struct_create Vec { v6, v7, v5 }
        ret v8

}

fn Vec::len(arg0: *Vec) -> i32 {

    block0:
        v10 = load Vec, v9
        v11 = struct_get v10, 1
        ret v11

}

fn Vec::capacity(arg0: *Vec) -> i32 {

    block0:
        v13 = load Vec, v12
        v14 = struct_get v13, 2
        ret v14

}

fn Vec::grow(arg0: *Vec) -> () {

    block0:
        v16 = load Vec, v15
        v17 = struct_get v16, 0
        v18 = load Vec, v15
        v19 = struct_get v18, 2
        v20 = iconst i32 0
        v21 = icmp eq v19, v20
        br_if v21, then: block1(), else: block2()

    block1:
        v22 = iconst i32 1
        br block3(v22)

    block2:
        v23 = iadd v19, v19
        br block3(v23)

    block3(v24: i32):
        v25 = call 81923(v24)
        v26 = load Vec, v15
        v27 = struct_get v26, 1
        v28 = iconst i32 0
        v29 = icmp sgt v27, v28
        br_if v29, then: block4(), else: block5()

    block4:
        v30 = load Vec, v15
        v31 = struct_get v30, 1
        v32 = call 988124(v17, v25, v31)
        br block5

    block5:
        v33 = iconst i8 0
        v34 = iconst i32 0
        v35 = icmp sgt v19, v34
        br_if v35, then: block6(), else: block7()

    block6:
        v36 = call 22882(v17, v19)
        br block7

    block7:
        v37 = iconst i8 0
        v38 = alloca *Vec ; loc0
        store *Vec, v38, v15
        v39 = load *Vec, v38
        v40 = iconst i32 0
        v41 = iconst i32 0
        v42 = gep v39, [v40, v41]
        store *T, v42, v25
        v43 = load *Vec, v38
        v44 = iconst i32 0
        v45 = iconst i32 2
        v46 = gep v43, [v44, v45]
        store i32, v46, v24
        ret

}

fn Vec::push(arg0: *Vec, arg1: T) -> () {

    block0:
        v49 = load Vec, v47
        v50 = struct_get v49, 0
        v51 = load Vec, v47
        v52 = struct_get v51, 2
        v53 = iconst i32 0
        v54 = icmp eq v52, v53
        br_if v54, then: block1(), else: block2()

    block1:
        v55 = iconst i32 1
        br block3(v55)

    block2:
        v56 = iadd v52, v52
        br block3(v56)

    block3(v57: i32):
        v58 = load Vec, v47
        v59 = struct_get v58, 1
        v60 = load Vec, v47
        v61 = struct_get v60, 2
        v62 = icmp eq v59, v61
        br_if v62, then: block4(), else: block5()

    block4:
        v63 = call 827472(v50, v52, v57)
        br block6(v63)

    block5:
        v64 = load Vec, v47
        v65 = struct_get v64, 0
        br block6(v65)

    block6(v66: *T):
        v67 = load Vec, v47
        v68 = struct_get v67, 1
        v69 = load Vec, v47
        v70 = struct_get v69, 2
        v71 = icmp eq v68, v70
        br_if v71, then: block7(), else: block8()

    block7:
        br block9(v57)

    block8:
        v72 = load Vec, v47
        v73 = struct_get v72, 2
        br block9(v73)

    block9(v74: i32):
        v75 = alloca *Vec ; loc0
        store *Vec, v75, v47
        v76 = load *Vec, v75
        v77 = iconst i32 0
        v78 = iconst i32 0
        v79 = gep v76, [v77, v78]
        store *T, v79, v66
        v80 = load *Vec, v75
        v81 = iconst i32 0
        v82 = iconst i32 2
        v83 = gep v80, [v81, v82]
        store i32, v83, v74
        v84 = load *Vec, v75
        v85 = iconst i32 0
        v86 = iconst i32 0
        v87 = gep v84, [v85, v86]
        v88 = load *T, v87
        v89 = load *Vec, v75
        v90 = load Vec, v89
        v91 = struct_get v90, 1
        v92 = gep v88, [v91]
        store T, v92, v48
        v93 = load *Vec, v75
        v94 = load Vec, v93
        v95 = struct_get v94, 1
        v96 = iconst i32 1
        v97 = iadd v95, v96
        v98 = load *Vec, v75
        v99 = iconst i32 0
        v100 = iconst i32 1
        v101 = gep v98, [v99, v100]
        store i32, v101, v97
        ret

}

fn Vec::pop(arg0: *Vec) -> Option {

    block0:
        v103 = load Vec, v102
        v104 = struct_get v103, 1
        v105 = iconst i32 0
        v106 = icmp eq v104, v105
        br_if v106, then: block1(), else: block2()

    block1:
        v107 = enum_create Option, variant 0
        br block3(v107)

    block2:
        v108 = load Vec, v102
        v109 = struct_get v108, 1
        v110 = iconst i32 1
        v111 = isub v109, v110
        v112 = alloca *Vec ; loc0
        store *Vec, v112, v102
        v113 = load *Vec, v112
        v114 = iconst i32 0
        v115 = iconst i32 1
        v116 = gep v113, [v114, v115]
        store i32, v116, v111
        v117 = load *Vec, v112
        v118 = load Vec, v117
        v119 = struct_get v118, 0
        v120 = load *Vec, v112
        v121 = load Vec, v120
        v122 = struct_get v121, 1
        v123 = gep v119, [v122]
        v124 = load T, v123
        v125 = enum_create Option, variant 1 [v124]
        br block3(v125)

    block3(v126: Option):
        ret v126

}

fn Vec::get(arg0: *Vec, arg1: i32) -> Option {

    block0:
        v129 = load Vec, v127
        v130 = struct_get v129, 1
        v131 = icmp sge v128, v130
        br_if v131, then: block1(), else: block2()

    block1:
        v132 = enum_create Option, variant 0
        br block3(v132)

    block2:
        v133 = load Vec, v127
        v134 = struct_get v133, 0
        v135 = gep v134, [v128]
        v136 = load T, v135
        v137 = enum_create Option, variant 1 [v136]
        br block3(v137)

    block3(v138: Option):
        ret v138

}

fn Vec::index(arg0: *Vec, arg1: i32) -> Option {

    block0:
        v141 = load Vec, v139
        v142 = struct_get v141, 1
        v143 = icmp sge v140, v142
        br_if v143, then: block1(), else: block2()

    block1:
        v144 = enum_create Option, variant 0
        br block3(v144)

    block2:
        v145 = load Vec, v139
        v146 = struct_get v145, 0
        v147 = gep v146, [v140]
        v148 = load T, v147
        v149 = enum_create Option, variant 1 [v148]
        br block3(v149)

    block3(v150: Option):
        ret v150

}

fn test_vec() -> () {

    block0:
        v151 = call 79020()
        v152 = alloca Vec ; loc0
        store Vec, v152, v151
        v153 = iconst i32 1
        v154 = call 17586(v152, v153)
        v155 = iconst i32 2
        v156 = call 17586(v152, v155)
        v157 = iconst i32 3
        v158 = call 17586(v152, v157)
        v159 = load Vec, v152
        v160 = alloca Vec ; loc0
        store Vec, v160, v159
        v161 = call 77089(v160)
        v162 = iconst i32 3
        v163 = icmp eq v161, v162
        br_if v163, then: block1(), else: block2()

    block1:
        v164 = iconst i8 0
        br block3

    block2:
        v165 = call 632151()
        br block3

    block3:
        v166 = iconst i8 0
        v167 = call 777106(v160)
        v168 = iconst i32 4
        v169 = icmp eq v167, v168
        br_if v169, then: block4(), else: block5()

    block4:
        v170 = iconst i8 0
        br block6

    block5:
        v171 = call 632151()
        br block6

    block6:
        v172 = iconst i8 0
        v173 = iconst i32 4
        v174 = call 17586(v160, v173)
        v175 = call 77089(v160)
        v176 = iconst i32 4
        v177 = icmp eq v175, v176
        br_if v177, then: block7(), else: block8()

    block7:
        v178 = iconst i8 0
        br block9

    block8:
        v179 = call 632151()
        br block9

    block9:
        v180 = iconst i8 0
        v181 = call 777106(v160)
        v182 = iconst i32 4
        v183 = icmp eq v181, v182
        br_if v183, then: block10(), else: block11()

    block10:
        v184 = iconst i8 0
        br block12

    block11:
        v185 = call 632151()
        br block12

    block12:
        v186 = iconst i8 0
        v187 = iconst i32 2
        v188 = call 72290(v160, v187)
        v189 = enum_get_tag v188
        v190 = iconst i32 0
        switch v189 { v190 => block14(), default: block15() }

    block13(v191: i32):
        v192 = iconst i32 3
        v193 = icmp eq v191, v192
        br_if v193, then: block16(), else: block17()

    block14:
        v194 = iconst i32 1
        v195 = ineg v194
        br block13(v195)

    block15:
        v196 = iconst i32 3
        br block13(v196)

    block16:
        v197 = iconst i8 0
        br block18

    block17:
        v198 = call 632151()
        br block18

    block18:
        v199 = iconst i8 0
        v200 = iconst i32 1
        v201 = call 407518(v160, v200)
        v202 = enum_get_tag v201
        v203 = iconst i32 0
        switch v202 { v203 => block20(), default: block21() }

    block19(v204: i32):
        v205 = iconst i32 2
        v206 = icmp eq v204, v205
        br_if v206, then: block22(), else: block23()

    block20:
        v207 = iconst i32 1
        v208 = ineg v207
        br block19(v208)

    block21:
        v209 = iconst i32 2
        br block19(v209)

    block22:
        v210 = iconst i8 0
        br block24

    block23:
        v211 = call 632151()
        br block24

    block24:
        v212 = iconst i8 0
        v213 = call 81245(v160)
        v214 = enum_get_tag v213
        v215 = iconst i32 0
        switch v214 { v215 => block26(), default: block27() }

    block25(v216: i32):
        v217 = iconst i32 4
        v218 = icmp eq v216, v217
        br_if v218, then: block28(), else: block29()

    block26:
        v219 = iconst i32 1
        v220 = ineg v219
        br block25(v220)

    block27:
        v221 = iconst i32 4
        br block25(v221)

    block28:
        v222 = iconst i8 0
        br block30

    block29:
        v223 = call 632151()
        br block30

    block30:
        v224 = iconst i8 0
        v225 = call 77089(v160)
        v226 = iconst i32 3
        v227 = icmp eq v225, v226
        br_if v227, then: block31(), else: block32()

    block31:
        v228 = iconst i8 0
        br block33

    block32:
        v229 = call 632151()
        br block33

    block33:
        v230 = iconst i8 0
        ret

}
